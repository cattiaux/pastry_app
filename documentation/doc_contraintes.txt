Synthèse des Contraintes pour le Modèle Category


        CONTRAINTES	                                                                 TEST CORRESPONDANT
Création d’une catégorie	                                                        -> test_create_category
category_name unique (en API, unique=True en production)                            -> test_create_duplicate_category
category_name et parent_category normalisé en minuscule                             -> test_normalized_fields_category_api
category_name ne peut pas être vide                                                 -> test_required_fields_category_api
Mise à jour du category_name                                                        -> test_update_category
Suppression d’une catégorie existante                                               -> test_delete_category
Récupération d’une catégorie existante                                              -> test_get_category
Erreur 404 si catégorie inexistante	                                                -> test_get_nonexistent_category et test_delete_nonexistent_category
Suppression bloquée si la catégorie est utilisée (ingredient ou recipe)             -> test_delete_category_with_linked_objects
category_type doit être une valeur valide (recipe, ingredient, both)                -> test_create_category_invalid_type
Mise à jour interdite vers un category_name déjà existant                           -> test_update_category_to_duplicate_api
Suppression d’une catégorie avec des sous-catégories	                            -> test_delete_category_with_subcategories (API) & test_delete_category_with_subcategories_model (Base)
Mise à jour partielle (PATCH) du parent_category	                                -> test_partial_update_category
Création d’une catégorie avec un parent_category invalide	                        -> test_create_category_with_invalid_parent
Création d’une catégorie avec un parent_category valide	                            -> test_parent_category_validation
Détachement d’une sous-catégorie (parent_category=None)                         	-> test_parent_category_is_optional
Vérification de la normalisation de category_type (ex: uppercase ➝ lowercase)      	-> test_normalized_fields_category_api
Règle parent_category / category_type                                               -> test_category_parent_type_model, test_category_parent_type_api


Contraintes Métier :
    1. Nom de Catégorie (category_name) :
        ◦ Doit être unique (contrôle API et DB en production).
        ◦ Ne peut pas être vide.
        ◦ Est normalisé en minuscule.
    2. Type de Catégorie (category_type) : 
        ◦ Doit être l’une des valeurs suivantes : recipe, ingredient, both.
        ◦ Doit être validé en API et en base de données.
        ◦ Normalisation automatique en minuscule.
    3. Parent de Catégorie (parent_category)
        ◦ Peut être NULL (catégorie racine).
        ◦ Si défini, doit être un category_name existant.
        ◦ Peut être modifié via PATCH.
        ◦ Une sous-catégorie peut être détachée de son parent (parent_category=None).
    Cohérence type parent/enfant :
        ◦ Une catégorie de type 'ingredient' ne peut avoir pour parent qu'une catégorie 'ingredient' ou 'both'.
        ◦ Une catégorie de type 'recipe' ne peut avoir pour parent qu'une catégorie 'recipe' ou 'both'.
        ◦ Une catégorie de type 'both' ne peut avoir pour parent qu'une catégorie 'both' ou aucun parent.
        ◦ Si le parent est 'both', il peut avoir des enfants de tout type.

Contraintes Techniques :
    1. Type de Données :
        ◦ category_name : CharField (max 200 caractères, valeurs prédéfinies).
        ◦ category_type : CharField (max 10 caractères, doit être recipe, ingredient, both).
        ◦ parent_category : ForeignKey vers self, optionnel (on_delete=models.SET_NULL)
    2. Indexation :
        ◦ category_name est indexé pour des recherches rapides.

Contraintes d'Intégrité :
    1. Références :
        ◦ Category est liée aux modèles Ingredient et Recipe.
    2. Cohérence des Données :
        ◦ Mises à jour contrôlées (test_update_category).
        ◦ Suppression gérée avec précaution (test_delete_category_with_linked_objects).
    3. Protection contre les suppressions invalides
        ◦ Si une Category est utilisée par un Ingredient ou une Recipe, elle ne peut pas être supprimée.
        ◦ Gestion via on_delete=PROTECT dans PostgreSQL.
        ◦ Vérification ajoutée dans destroy() de CategoryViewSet

Gestion de la Suppression d'une Catégorie avec des Sous-Catégories
    Suppression d'une catégorie sans sous-catégories                                    -> Suppression directe
    Suppression d'une catégorie avec des sous-catégories (on_delete=models.SET_NULL)    -> parent_category des sous-catégories devient NULL
    Suppression avec ?delete_subcategories=true                                         -> Supprime aussi les sous-catégories
    Suppression impossible si la catégorie est liée à une recette ou un ingrédient

Préparation pour la Production :
    Ajout de unique=True sur category_name en production :
        ◦ Actuellement, category_name n’a pas unique=True pour éviter des conflits en développement et permettre des tests.
        ◦ Une fois en production, unique=True sera ajouté pour garantir l’unicité en base.
        ◦ L’API empêche déjà les doublons, donc aucune erreur 500 (IntegrityError) ne devrait survenir après l’activation.



Synthèse des Contraintes pour le Modèle Label

        CONTRAINTES	                                                                 TEST CORRESPONDANT
Création d’un label     	                                                     -> test_create_label
label_name unique (géré en API, unique=True en production)                       -> test_create_duplicate_label_api
label_name normalisé en minuscule                                                -> test_normalized_fields_label_api
label_name ne peut pas être vide                                                 -> test_required_fields_label_api
Mise à jour du label_name                                                        -> test_label_update
Suppression d’un label existant                                                  -> test_delete_label
Récupération d’un label existant                                                 -> test_get_label
Erreur 404 si le label inexistante	                                             -> test_get_nonexistent_label et test_delete_nonexistent_label
Suppression bloquée si le label est utilisé (ingredient ou recipe)               -> test_delete_label_with_linked_objects
label_type doit être une valeur valide (recipe, ingredient, both)	             -> test_create_label_invalid_type
Mise à jour interdite vers un label_name déjà existant                           -> test_update_label_to_duplicate_api
Vérification de la normalisation de label_type (ex: uppercase ➝ lowercase)	     -> test_normalized_fields_label_api
Un utilisateur non-admin ne peut pas créer un label	                             -> test_non_admin_cannot_create_label
Un utilisateur non-admin ne peut pas supprimer un label	                         -> test_non_admin_cannot_delete_label

Contraintes Métier :
    1. Nom de Label (label_name) :
        ◦ Doit être unique.
        ◦ Ne peut pas être vide.
        ◦ Est normalisé en minuscule avant stockage.
    2. Type de Label (label_type) : 
        ◦ Doit être l’une des valeurs suivantes : recipe, ingredient, both.
        ◦ Doit être validé en API et en base de données.
        ◦ Normalisation automatique en minuscule.

Contraintes Techniques :
    1. Type de Données :
        ◦ label_name : CharField (max 200 caractères, unique=True en production).
        ◦ label_type : CharField (max 10 caractères, doit être recipe, ingredient, both).
    2. Indexation :
        ◦ label_name est indexé pour optimiser les recherches.
    3. Gestion des Permissions : 
        ◦ Tous les utilisateurs peuvent lire les labels, mais seuls les admins peuvent créer, modifier et supprimer.

Contraintes d'Intégrité :
    1. Références :
        ◦ Label est liée aux modèles Ingredient et Recipe via les tables intermédiaires IngredientLabel et RecipeLabel.
    2. Cohérence des Données :
        ◦ Mises à jour contrôlées.
        ◦ SSuppression gérée avec précaution.
    3. Protection contre les suppressions invalides
        ◦ Si un label est utilisé par un Ingredient ou une Recipe, il ne peut pas être supprimé.
        ◦ Gestion via on_delete=PROTECT dans PostgreSQL.
        ◦ Vérification ajoutée dans destroy() de LabelViewSet

Préparation pour la Production :
    Ajout de unique=True sur label_name en production :
        ◦ Actuellement, label_name n’a pas unique=True pour éviter des conflits en développement et permettre des tests.
        ◦ Une fois en production, unique=True sera ajouté pour garantir l’unicité en base.
        ◦ L’API empêche déjà les doublons, donc aucune erreur 500 (IntegrityError) ne devrait survenir après l’activation.




Synthèse des Contraintes pour le Modèle Ingredient

        CONTRAINTES	                                                                 TEST CORRESPONDANT
Création d’un ingrédient	                                                -> test_create_ingredient
ingredient_name unique (en API, unique=True en production)	                -> test_create_duplicate_ingredient
ingredient_name normalisé (minuscule, sans espaces inutiles)	            -> test_ingredient_name_is_normalized
ingredient_name ne peut pas être vide	                                    -> test_ingredient_name_cannot_be_empty
Mise à jour du ingredient_name	                                            -> test_update_ingredient_name
Suppression d’un ingrédient existant	                                    -> test_delete_ingredient
Récupération d’un ingrédient existant                                       -> test_get_ingredient
Erreur 404 si ingrédient inexistant	                                        -> test_get_nonexistent_ingredient, test_delete_nonexistent_ingredient
Suppression bloquée si l’ingrédient est utilisé dans une recette        	-> test_delete_ingredient_used_in_recipe
Ajout d’un ingrédient avec une catégorie existante                      	-> test_create_ingredient_with_category
Ajout d’un ingrédient avec un label existant	                            -> test_create_ingredient_with_label
Interdiction d’assigner une catégorie inexistante	                        -> test_create_ingredient_with_nonexistent_category
Interdiction d’assigner un label inexistant                             	-> test_create_ingredient_with_nonexistent_label
Mise à jour interdite vers un ingredient_name déjà existant	                -> test_update_ingredient_to_duplicate
Suppression de catégorie/label uniquement si non utilisé	                -> test_update_ingredient_remove_category, test_update_ingredient_remove_label


Contraintes Métier :
1. Nom de l’Ingrédient (ingredient_name)
    ◦ Doit être unique.
    ◦ Ne peut pas être vide.
    ◦ Est normalisé en minuscule sans espaces superflus.
    ◦ Ne peut pas être uniquement numérique ("1234" est invalide).
    ◦ Doit contenir au moins 2 caractères.
2. Catégories & Labels
    ◦ Un ingrédient peut appartenir à plusieurs catégories et labels.
    ◦ Un ingrédient peut ne pas avoir de catégorie ni de label.
    ◦ Impossible d’assigner une catégorie ou un label inexistant en base.
3. Gestion des Suppressions
    ◦ Un ingrédient ne peut pas être supprimé s'il est utilisé dans une recette.
    ◦ Les catégories et labels peuvent être retirés d’un ingrédient uniquement s’ils existent encore ailleurs.
    ◦ Un Ingredient supprimé supprime tous ses prix en cours (IngredientPrice), mais conserve l’historique (IngredientPriceHistory) avec ingredient_name.

Contraintes Techniques :
1. Type de Données
    ◦ ingredient_name : CharField (200 caractères max, normalisé).
    ◦ categories : ManyToManyField(Category, related_name="ingredients").
    ◦ labels : ManyToManyField(Label, related_name="ingredients").
2. Indexation
    ◦ ingredient_name est indexé pour accélérer les recherches.

Contraintes d'Intégrité :
1. Références
    ◦ Ingredient est lié à Recipe via RecipeIngredient.
    ◦ Ingredient est lié à Category et Label via ManyToManyField.
2. Cohérence des Données
    ◦ Validation en API et en base (full_clean() avant save()).
    ◦ Impossible d’assigner une catégorie ou un label inexistant.
    ◦ Suppression sécurisée : on_delete=PROTECT pour empêcher la suppression d’un ingrédient utilisé dans une recette.

Préparation pour la Production
    1. Ajout de unique=True sur ingredient_name
        ◦ Actuellement, ingredient_name n’a pas unique=True pour éviter des erreurs bloquantes en développement et permettre les tests.
        ◦ Une fois en production, unique=True sera activé pour garantir l’unicité en base.
        ◦ L’API continuera d’appliquer la validation d’unicité pour éviter des erreurs IntegrityError.
    2. Gestion des Suppressions
            ◦ Vérification stricte via on_delete=PROTECT pour interdire la suppression d’un ingrédient s’il est utilisé.
            ◦ Double protection :
                ◦ Vérification au niveau API (destroy() dans IngredientViewSet).
                ◦ Vérification en base (PROTECT sur RecipeIngredient.ingredient).





Synthèse des Contraintes pour le Modèle Store


Création	
Vérifie la création d’un magasin	
Vérifie la normalisation du store_name	
Vérifie qu’on ne peut pas créer un magasin en doublon	
Vérifie qu’un store doit avoir soit city, soit zip_code	
Lecture	
Récupération d’un magasin existant	
Vérifie qu’un GET sur un store inexistant retourne une erreur 404
Mise à jour	
Vérifie la modification d’un champ unique (store_name, city, zip_code)
Vérifie qu’on ne peut pas modifier un store pour en faire un doublon
Suppression	
Vérifie qu’on peut supprimer un magasin existant
Vérifie qu’une tentative de suppression d’un magasin inexistant retourne une erreur 404

        CONTRAINTES	                                                                 TEST CORRESPONDANT
Création d’un store valide	                                                -> test_create_store
store_name obligatoire                                                      -> test_required_fields_store, test_required_fields_store_api
city ou zip_code obligatoire                                               	-> test_store_requires_city_or_zip_code
store_name et city normalisés (minuscule, sans espaces inutiles)            -> test_normalized_fields_store, test_normalized_fields_store_api
Longueur minimale de store_name et city                                     -> test_min_length_fields_store, test_min_length_fields_store_api
Mise à jour du store_name                                                   -> test_store_update, test_update_store_to_duplicate_api
Suppression d’un store existant                                             -> test_store_deletion
Interdiction de créer deux stores identiques (unique_together)              -> test_unique_constraint_store, test_unique_together_store_api
Erreur 400 si city et zip_code sont absents                                 -> test_store_requires_city_or_zip_code, test_store_requires_city_or_zip_code_api
Suppression bloquée si store utilisé dans un prix d’ingrédient              -> test_delete_store_used_in_prices


Contraintes Métier:
1. Nom du Store (store_name)
    ◦ Doit être obligatoirement renseigné.
    ◦ Doit contenir au moins 2 caractères.
    ◦ Normalisé en minuscule sans espaces superflus.
2. Ville (city) et Code Postal (zip_code)
    ◦ Au moins l’un des deux doit être renseigné.
    ◦ Peuvent être vides individuellement mais pas ensemble.
3. Unicité
    ◦ Deux magasins ne peuvent pas avoir simultanément le même store_name, city et zip_code.
4. Suppression sécurisée
    ◦ Un magasin ne peut pas être supprimé s’il est utilisé dans un IngredientPrice.

Contraintes Techniques:
1. Type de Donnée
    ◦ store_name : CharField (normalisé en minuscule, sans espaces superflus).
    ◦ city : CharField (optionnel si zip_code est présent).
    ◦ zip_code : CharField (optionnel si city est présent).
2. Indexation	
    ◦ Index sur (store_name, city, zip_code) pour optimiser la recherche et garantir l’unicité logique.

Contraintes d’Intégrité :
1. Références :
    ◦ Store est lié à IngredientPrice via une ForeignKey.
    ◦ Si un Store est utilisé dans IngredientPrice, sa suppression est interdite (on_delete=PROTECT)
2. Cohérence des Données :
    ◦ Unicité d’un store : Validation métier en API et en base (full_clean() avant save()).
    ◦ Un store doit toujours avoir une city ou un zip_code.
    ◦ Un store ne peut pas être supprimé s'il est référencé dans IngredientPrice.
    ◦ Suppression : Vérifié via les tests CRUD
    ◦ Normalisation des noms : Vérifié via test_store_fields_are_normalized

Préparation à la Production : 
1. Ajout de Contrainte d’Unicité
    ◦ Actuellement, unique_together est appliqué via l’API, mais pas directement en base pour faciliter les tests.
    ◦ En production, on pourra ajouter une contrainte unique en base de données.




Synthèse des Contraintes pour le Modèle IngredientPrice


        CONTRAINTES	                                                                                 TEST CORRESPONDANT
Création d’un IngredientPrice valide	                                                        -> test_create_ingredientprice_api
Vérifie que ingredient, store, price, quantity, unit sont obligatoires	                        -> test_required_fields_ingredientprice_db, test_required_fields_ingredientprice_api
Vérifie que unit est bien dans UNIT_CHOICES et normalisé	                                    -> test_invalid_choice_fields_ingredientprice_db, test_invalid_choice_fields_ingredientprice_api, test_normalized_fields_ingredientprice_db, test_normalized_fields_ingredientprice_api
Vérifie que brand_name et unit sont bien normalisés	                                            -> test_normalized_fields_ingredientprice_db, test_normalized_fields_ingredientprice_api
Vérifie que price et quantity doivent être strictement positifs	                                -> test_positive_values_ingredientprice_db, test_positive_values_ingredientprice_api
Vérifie qu’un IngredientPrice est unique (même ingredient, store, brand_name, quantity, unit)	-> test_unique_constraint_ingredientprice_db, test_unique_together_ingredientprice_api
Vérifie qu’on ne peut pas modifier un IngredientPrice	                                        -> test_update_ingredientprice_api_forbidden
Vérifie que la mise à jour d’un prix crée un nouvel IngredientPrice et archive l’ancien	        -> test_price_update_creates_new_ingredientprice
Vérifie qu’un IngredientPrice peut être supprimé	                                            -> test_delete_ingredientprice_api
Vérifie qu’on ne peut pas supprimer un IngredientPrice utilisé dans IngredientPriceHistory	    -> test_delete_ingredientprice_api_forbidden
Vérifie que la suppression d’un Ingredient supprime bien ses prix actuels                       -> test_ingredient_deletion_removes_prices

Contraintes Métier:
1. Obligations des Champs
    ◦ ingredient, store, price, quantity et unit sont obligatoires.
    ◦ brand_name est optionnel mais normalisé.
    ◦ date est facultatif mais par défaut fixé à la date du jour.
2. Validation des Valeurs
    ◦ price et quantity doivent être strictement positifs.
    ◦ unit doit appartenir à UNIT_CHOICES et est normalisé ("Kg" → "kg").
3. Unicité
    ◦ Un IngredientPrice est unique sur (ingredient, store, brand_name, quantity, unit).
    ◦ Si le prix change pour un même ingrédient, l’ancien est archivé dans IngredientPriceHistory.
4. Mise à Jour
    ◦ Pas d’update d’un IngredientPrice (nouvel enregistrement à chaque changement).
    ◦ Seule la modification de promotion_end_date est autorisée.
5. Suppression Sécurisée
    ◦ Un IngredientPrice supprimé est automatiquement archivé dans IngredientPriceHistory.

Contraintes Techniques:
1. Type de Données
    ◦ price et quantity sont stockés en DecimalField, mais acceptent des int (convertis en float).
    ◦ unit est un CharField avec des choix limités (UNIT_CHOICES).
2. Indexation
    ◦ Index sur (ingredient, store, brand_name, quantity, unit) pour optimiser les requêtes.
    ◦ Index sur date pour les recherches temporelles.
3. Gestion des suppressions
    on_delete=models.CASCADE sur l'ingrédient → Supprime les prix actifs avec l’ingrédient.




Synthèse des Contraintes pour le Modèle IngredientPriceHistory

        CONTRAINTES	                                                                                 TEST CORRESPONDANT
Récupération d’un historique spécifique	                                        -> test_get_ingredientpricehistory_detail_api
Vérifie qu’on peut récupérer la liste des historiques	                        -> test_get_ingredientpricehistory_list_api
Vérifie que la création d’un IngredientPriceHistory est interdite via l’API	    -> test_create_ingredientpricehistory_api_forbidden
Vérifie qu’un IngredientPriceHistory est bien créé lorsqu’un prix change	    -> test_price_update_creates_new_ingredientprice
Vérifie que la mise à jour d’un historique de prix est interdite via l’API	    -> test_update_ingredientpricehistory_api_forbidden
Vérifie que la suppression d’un historique de prix est interdite via l’API	    -> test_delete_ingredientpricehistory_api_forbidden
Vérifie que l’historique est bien conservé après suppression d’un ingrédient    -> test_ingredient_deletion_keeps_history
Vérifie que la suppression d’un prix l’archive dans l'historique.               -> test_ingredientprice_deletion_creates_history

Contraintes Métier:
0. Création
    ◦ L’archivage d’un prix est automatique lorsqu’un prix existant est modifié.
    ◦ Un IngredientPriceHistory est généré automatiquement, il ne peut pas être créé ou modifié manuellement.
1. Obligations des Champs
    ◦ ingredient, store, price, quantity, unit et date sont obligatoires.
    ◦ is_promo et promotion_end_date doivent être cohérents (promotion_end_date requiert is_promo=True).
2. Validation des Valeurs
    ◦ price et quantity doivent être strictement positifs.
    ◦ unit est validé et normalisé ("Kg" → "kg").
3. Unicité
    ◦ Pas de contrainte stricte en base sur (date, price), mais les doublons inutiles sont empêchés via clean().
4. Lecture et Protection
    ◦ IngredientPriceHistory est en lecture seule via l’API (ReadOnlyModelViewSet).
    ◦ Aucune modification ni suppression autorisée via l’API.
5. Historique
    ◦ L’historique d’un ingrédient supprimé ne référence plus l’ingrédient en ForeignKey, mais conserve son nom (ingredient_name).

Contraintes Techniques:
1. Type de Données
    ◦ price et quantity sont stockés en DecimalField, comme dans IngredientPrice.
    ◦ date est un DateField obligatoire.
    ◦ on_delete=models.SET_NULL sur l'ingrédient → Conserve l’historique sans référence directe.
    ◦ L’ingredient_name de IngredientPriceHistory est mis à jour lors de l’archivage.
2. Indexation
    ◦ Index sur (ingredient, date) pour améliorer les performances.
3. Intégrité
    ◦ Lecture seule via l’API.
    ◦ Suppression interdite en API, mais possible en base pour un superutilisateur uniquement.



Synthèse des Contraintes pour le Modèle RecipeStep

        CONTRAINTES	                                                                                 TEST CORRESPONDANT
Création d’une étape valide                             -> test_create_recipestep
step_number unique par recette                          -> test_unique_constraint_recipestep et test_unique_value_api
step_number doit être consécutif                       	-> test_step_number_must_be_strictly_increasing et test_step_number_must_be_strictly_increasing_api
step_number >= 1                                    	-> test_step_number_must_start_at_1 et test_step_number_must_start_at_1_api
Auto-incrémentation de step_number	                    -> test_step_number_auto_increment et test_create_step_auto_increment_api
instruction obligatoire	                                -> test_required_fields_recipestep et test_required_fields_recipestep_api
instruction longueur minimale                        	-> test_min_length_instruction_recipestep et test_min_length_fields_recipestep_api
trick est un champ optionnel	                        -> test_optional_field_recipestep et test_trick_is_optional_api
Mise à jour d’un RecipeStep	                            -> test_recipestep_update et test_partial_update_recipestep
Suppression d’un RecipeStep	                            -> test_recipestep_deletion et test_delete_recipestep
Suppression interdite du dernier RecipeStep	            -> test_cannot_delete_last_recipe_step et test_cannot_delete_last_recipestep_api
Suppression d’un RecipeStep réorganise les numéros	    -> test_deleting_step_reorders_steps
Suppression d’un RecipeStep inexistant	                -> test_delete_nonexistent_recipestep
Récupération d’un RecipeStep existant	                -> test_get_recipestep
Erreur 404 si RecipeStep inexistant	                    -> test_get_nonexistent_recipestep

Contraintes Métier:
1. step_number
    ◦ Doit être unique pour une même recette.
    ◦ Doit être consécutif (ex : 1 → 2 → 3, pas 1 → 3).
    ◦ Doit être ≥ 1.
    ◦ Si non fourni, il est auto-incrémenté.
2. instruction
    ◦ Obligatoire.
    ◦ Doit avoir au moins 5 caractères.
3. trick
    ◦ Optionnel (None ou "").

Contraintes Techniques:
1. Type de Données
    ◦ recipe : ForeignKey(Recipe) -> Lié à Recipe, suppression en cascade (on_delete=models.CASCADE)
    ◦ step_number : IntegerField -> MinValueValidator(1), unique avec recipe
    ◦ instruction : TextField -> max_length=250
    ◦ trick : TextField	-> max_length=100, null=True, blank=True
2. Indexation
    ◦ step_number est indexé pour des recherches rapides.
    ◦ Contrainte unique_together ("recipe", "step_number") appliquée en base.

Contraintes d'Intégrité :
1. Références
    ◦ RecipeStep est lié à Recipe.
2. Cohérence des Données
    ◦ Mise à jour contrôlée (test_recipestep_update).
    ◦ Suppression gérée avec précaution (test_cannot_delete_last_recipe_step).
    ◦ Si le step_number n'est pas fourni il est calculé automatiquement.
3. Protection contre les suppressions invalides
    ◦ Si une recette n’a qu’un seul RecipeStep, la suppression est bloquée.
    ◦ Après suppression d’un RecipeStep, les step_number sont réorganisés.



Synthèse des Contraintes pour le Modèle RecipeIngredient

        CONTRAINTES	                                                                                 TEST CORRESPONDANT
Création d’un RecipeIngredient	                                                    -> test_create_recipeingredient_api
quantity doit être strictement positive	                                            -> test_recipeingredient_quantity_must_be_positive_db & test_quantity_must_be_positive_api
unit doit être une valeur valide (existe dans UNIT_CHOICES)             	        -> test_unit_must_be_valid_recipeingredient_db & test_unit_must_be_valid_choice_api
quantity et unit sont obligatoires	                                                -> test_required_fields_recipeingredient_db & test_required_fields_recipeingredient_api
Mise à jour de quantity et unit	                                                    -> test_recipeingredient_update_db & test_partial_update_recipeingredient_api
Suppression d’un RecipeIngredient existant	                                        -> test_delete_recipeingredient_api
Suppression impossible si c’est le dernier ingrédient d’une recette             	-> test_cannot_delete_last_recipe_ingredient_model & test_cannot_delete_last_recipeingredient_api
Récupération d’un RecipeIngredient existant	                                        -> test_get_recipeingredient_api
Liste des RecipeIngredient pour une recette                                     	-> test_list_recipeingredient_api
Erreur 404 si RecipeIngredient inexistante	                                        -> test_get_nonexistent_recipeingredient_api & test_delete_nonexistent_recipeingredient_api
Suppression d’une RecipeIngredient réattribue correctement les suffixes	            -> test_suffix_reassignment_on_deletion & test_suffix_increment_and_reassignment_on_deletion_api
Ajout d’un ingrédient plusieurs fois doit générer un suffixe (Sucre 2, etc.)	    -> test_suffix_is_incremented & test_suffix_increment_on_duplicate_ingredient
Suppression d’une recette entraîne la suppression des RecipeIngredient associées	-> test_recipe_deletion_cascades_to_recipeingredient


Contraintes Métier :
1. Ingrédient dans une Recette
    ◦ Un RecipeIngredient doit toujours être lié à une Recipe et un Ingredient.
    ◦ Une recette ne peut pas exister sans au moins un RecipeIngredient.
    ◦ Un ingrédient peut apparaître plusieurs fois dans une recette, avec un suffixe (Sucre, Sucre 2, Sucre 3).
2. Quantité (quantity)
    ◦ Obligatoire (ne peut pas être null ou vide).
    ◦ Doit être strictement positive (> 0).
    ◦ Peut être mise à jour mais pas supprimée indépendamment
3. Unité (unit)
    ◦ Obligatoire.
    ◦ Doit être une valeur valide définie dans UNIT_CHOICES.
    ◦ Peut être mise à jour.
4. Gestion des Suffixes
    ◦ Lorsqu’un ingrédient est ajouté plusieurs fois dans une recette, un suffixe est ajouté (Sucre, Sucre 2, Sucre 3).
    ◦ Suppression d’un ingrédient réattribue les suffixes des suivants (Sucre 3 devient Sucre 2 si Sucre 2 est supprimé).
5. Suppression
    ◦ Un RecipeIngredient peut être supprimé, sauf si c'est le dernier de la recette.
    ◦ Suppression d’une recette entraîne la suppression de ses RecipeIngredient.
    ◦ Un ingrédient (Ingredient) peut être supprimé sans affecter les RecipeIngredient existants.


Contraintes Techniques :
1. Type de Données
    ◦ recipe : ForeignKey(Recipe) -> Obligatoire, on_delete=models.CASCADE
    ◦ ingredient : ForeignKey(Ingredient) -> Obligatoire, on_delete=models.PROTECT
    ◦ quantity : FloatField -> Obligatoire, MinValueValidator(0)
    ◦ unit : CharField(max_length=50) -> Obligatoire, choices=UNIT_CHOICES
    ◦ display_name : CharField(max_length=255) -> Gère les suffixes (Sucre 2, Sucre 3)
2. Indexation
    ◦ recipe et ingredient sont indexés pour optimiser les recherches.
    ◦ display_name est calculé dynamiquement (pas d’indexation nécessaire).

Contraintes d'Intégrité
1. Relations et Références
    ◦ RecipeIngredient est lié à Recipe et Ingredient.
    ◦ Un ingrédient (Ingredient) peut être supprimé, mais pas une recette sans ingrédient.
    ◦ on_delete=models.CASCADE pour recipe (supprime tous les RecipeIngredient associés).
    ◦ on_delete=models.PROTECT pour ingredient (évite de supprimer un ingrédient en usage).
2. Cohérence des Données
    ◦ Vérifications strictes lors de la création et de la mise à jour (quantity positive, unit valide).
    ◦ Validation métier et API cohérentes (Model + Serializer).
    ◦ Les mises à jour et suppressions respectent les règles métier.

Gestion de la Suppression :
   ◦ Suppression d’un RecipeIngredient s’il y en a d’autres -> Autorisé
   ◦ Suppression du dernier RecipeIngredient d’une recette -> Interdit (ValidationError)
   ◦ Suppression d’une Recipe -> Supprime tous les RecipeIngredient liés
   ◦ Suppression d’un Ingredient -> Autorisé, ne supprime pas les RecipeIngredient (protégé)
   ◦ Suppression d’un RecipeIngredient avec suffixe ->  Réattribue les suffixes des suivants (Sucre 3 devient Sucre 2)



Synthèse des Contraintes pour le Modèle SubRecipe

        CONTRAINTES	                                                    TEST CORRESPONDANT
Création d’une sous-recette valide	                            -> test_create_subrecipe
Suppression d’une sous-recette existante	                    -> test_delete_subrecipe_db & test_delete_subrecipe_api
Récupération d’une sous-recette existante	                    -> test_get_subrecipe_api
Modification de quantity et unit autorisée	                    -> test_update_subrecipe_quantity_and_unit_db & test_update_subrecipe_api
Modification du champ recipe interdite (modèle et API)	        -> test_cannot_update_recipe_field_in_subrecipe & test_cannot_update_recipe_field_api
Une recette ne peut pas être sa propre sous-recette	            -> test_cannot_add_recipe_as_its_own_subrecipe & test_cannot_set_recipe_as_its_own_subrecipe_api
Suppression bloquée si la sous-recette est utilisée	            -> test_cannot_delete_recipe_used_as_subrecipe & test_cannot_delete_recipe_used_as_subrecipe_api
quantity obligatoire et strictement positif	                    -> test_required_fields_subrecipe_db, test_quantity_must_be_positive_subrecipe_db, test_quantity_must_be_positive_api
unit obligatoire et valeur valide                       	    -> test_required_fields_subrecipe_db, test_unit_must_be_valid_subrecipe_db, test_unit_must_be_valid_choice_api
Champs recipe et sub_recipe obligatoires en API	                -> test_required_fk_fields_subrecipe_api
Erreur 404 pour une sous-recette inexistante            	    -> test_get_nonexistent_subrecipe, test_delete_nonexistent_subrecipe
Format lisible pour __str__()	                                -> test_subrecipe_str_method
Lecture de la liste des sous-recettes	                        -> test_list_subrecipe_api


Contraintes Métier :
1.Sous-recette (sub_recipe) :
    ◦ Une recette ne peut pas être sa propre sous-recette.
    ◦ Le champ sub_recipe est obligatoire.
    ◦ Le champ sub_recipe peut être modifié via l’API (pour changer la version de la sous-recette).
    ◦ sub_recipe est une FK vers Recipe, protégée (on_delete=PROTECT).
2. Recette principale (recipe) :
    ◦ Obligatoire à la création.
    ◦ Ne peut pas être modifiée après création (read_only=True dans l'API).
    ◦ FK vers Recipe, suppression en cascade (on_delete=CASCADE).
3. Quantité (quantity) :
    ◦ Obligatoire.
    ◦ Doit être un float.
    ◦ Doit être strictement positive (> 0).
4. Unité (unit) :
    ◦ Obligatoire.
    ◦ Doit appartenir aux UNIT_CHOICES.

Contraintes Techniques :
1. Type de Données
    ◦ quantity : FloatField avec MinValueValidator(0)
    ◦ unit : CharField avec choices=UNIT_CHOICES (géré à la fois en DB et en API)
    ◦ recipe : ForeignKey vers Recipe, on_delete=models.CASCADE
    ◦ sub_recipe : ForeignKey vers Recipe, on_delete=models.PROTECT

Contraintes d'Intégrité :
1. Références croisée :
    ◦ sub_recipe est une Recipe, donc une entité complète utilisée dans d'autres contextes.
2. Protection contre les suppressions invalides :
    ◦ Une sub_recipe utilisée ne peut pas être supprimée (ProtectedError).
    ◦ La suppression d’une SubRecipe ne supprime pas la sub_recipe.
3. Verrouillage logique :
    ◦ Une fois créée, une SubRecipe ne peut plus changer de recipe.

Gestion des erreurs spécifiques :
    ◦ Suppression d’une Recipe utilisée comme sub_recipe	-> ProtectedError / 400 Bad Request
    ◦ Création sans quantity, unit, recipe ou sub_recipe	-> ValidationError (400 Bad Request)
    ◦ Tentative de PATCH sur recipe	                        -> ValidationError (400 Bad Request)
    ◦ Doublon strict de sous-recette	                    -> ValidationError en API uniquement



### Synthèse des Contraintes pour le Modèle Pan

        CONTRAINTES	                                                        TEST CORRESPONDANT
Création d’un moule valide (type CUSTOM)	                            -> test_create_pan_api
pan_type obligatoire	                                                -> test_pan_type_required_db & test_required_fields_pan_api
pan_type doit avoir une valeur autorisée	                            -> test_invalid_pan_type_choices_db & test_choices_validation_pan_api
pan_name peut être auto-généré si absent	                            -> test_generate_default_name_round_db
pan_name doit être unique (case insensitive)	                        -> test_pan_name_is_unique_db & test_unique_constraint_api & test_update_to_duplicate_name_api
pan_name et pan_brand : longueur min. de 2	                            -> test_min_length_fields_db & test_min_length_fields_api
pan_name et pan_brand : normalisés via normalize_case()	                -> test_brand_is_optional_and_normalized_db & test_normalized_fields_pan_api
Création d’un Pan ROUND nécessite diameter + height	                    -> test_missing_required_fields_db & test_clean_validation_errors_pan_api
Création d’un Pan RECTANGLE nécessite length + width + rect_height	    -> test_missing_required_fields_db & test_clean_validation_errors_pan_api
Création d’un Pan CUSTOM nécessite volume_raw + unit	                -> test_missing_required_fields_db & test_clean_validation_errors_pan_api
Champs interdits selon pan_type (cohérence métier)	                    -> test_pan_type_exclusive_fields_model & test_post_exclusive_fields_pan_api & test_patch_exclusive_fields_pan_api
Champs numériques doivent respecter leur MinValueValidator	            -> test_min_value_constraints_api
PATCH partiel autorisé sans casse de données	                        -> test_patch_partial_fields_api
volume_cm3 et volume_cm3_cache : calculés & read-only	                -> test_volume_cm3_cache_is_returned & test_read_only_volume_cm3_api
Récupération d’un Pan (GET)	                                            -> test_get_pan_detail_api
Liste des Pans (GET)	                                                -> test_list_pans_api
Modification partielle (PATCH)	                                        -> test_patch_update_pan_api
Remplacement total (PUT)	                                            -> test_put_update_pan_api
Suppression d’un Pan existant	                                        -> test_delete_pan_api & test_delete_pan_db
Erreur 404 pour Pan inexistant	                                        -> test_get_nonexistent_pan & test_delete_nonexistent_pan

Contraintes Métier :
1. pan_type
    ◦ Obligatoire, doit être l’une des valeurs de PAN_TYPE_CHOICES
    ◦ Contrôle les champs requis et interdits (logique métier cruciale)
2. Champs requis par type
    ◦ ROUND : diameter, height
    ◦ RECTANGLE : length, width, rect_height
    ◦ CUSTOM : volume_raw, unit
3. Champs interdits selon type
    ◦ ROUND ne doit pas avoir : length, width, rect_height, volume_raw
    ◦ RECTANGLE ne doit pas avoir : diameter, height, volume_raw
    ◦ CUSTOM ne doit pas avoir de dimensions géométriques
4. pan_name (nom du moule)
    ◦ Optionnel à la création → généré automatiquement si absent
    ◦ Doit être unique (après normalisation)
    ◦ Doit faire au moins 2 caractères
5. pan_brand (marque)
    ◦ Optionnelle
    ◦ Normalisée si fournie
    ◦ Doit faire au moins 2 caractères si renseignée
6. Volume
    ◦ Calculé automatiquement selon les champs fournis et le pan_type
    ◦ Exposé en lecture seule via volume_cm3 et volume_cm3_cache

Contraintes Techniques : 
1. Type de Données
    ◦ pan_type : CharField, choices=PAN_TYPE_CHOICES, requis
    ◦ pan_name : CharField, unique, nullable, normalisé
    ◦ pan_brand : CharField, nullable, normalisé
    ◦ Dimensions (diameter, height, etc.) : FloatField, nullable, MinValueValidator(0.1)
    ◦ volume_raw : FloatField, MinValueValidator(1)
    ◦ unit : CharField, choices=UNIT_CHOICES
    ◦ volume_cm3_cache : FloatField, calculé automatiquement (enregistré en base)
    ◦ volume_cm3 : propriété Python, pas en base

Contraintes d’Intégrité :
1. Cohérence par type
    ◦ Contrôle strict dans clean() du modèle
    ◦ Les erreurs métier sont propagées côté API (via validate())
2. Champs calculés
    ◦ volume_cm3_cache mis à jour automatiquement à chaque save()
    ◦ Non modifiable via l’API
3. Unicité
    ◦ pan_name est unique (vérification DB + logique de normalisation)



### Synthèse des Contraintes pour le Modèle Recipe

            CONTRAINTES	                                                                    TEST CORRESPONDANT
Création d’une recette valide                                   	            → test_create_recipe_api
recipe_name, chef_name, recipe_type obligatoires	                            → test_required_fields_recipe_db & test_required_fields_recipe_api
Unicité du couple (recipe_name, chef_name, context_name)	                    → test_unique_constraint_recipe_db & test_unique_constraint_recipe_api
Nom et nom du chef normalisés (normalize_case)	                                → test_normalized_fields_recipe_db & test_normalized_fields_recipe_api
Contrainte de longueur minimale sur description, trick, context_name, source	→ test_min_length_fields_recipe_db & test_min_length_fields_recipe_api
Champs description, trick, context_name, source optionnels	                    → test_optional_fields_recipe_api
servings_min et servings_max doivent être ≥ 1	                                → test_servings_must_be_positive_recipe_db & test_servings_must_be_positive_recipe_api
servings_min ≤ servings_max	                                                    → test_servings_min_max_coherence_recipe_db & test_servings_min_max_coherence_recipe_api
Auto-remplissage : servings_min = servings_max si un seul fourni	            → test_auto_copy_servings_recipe_db
servings auto-générés depuis le Pan (et pan_quantity)	                        → test_auto_fill_servings_from_pan_db, test_servings_are_scaled_by_pan_quantity
context_name auto-rempli depuis parent_recipe si manquant	                    → test_context_is_auto_filled_if_missing
pan facultatif	                                                                → test_pan_is_optional_recipe_db
Pas de boucle sur soi-même comme parent	                                        → test_parent_recipe_cannot_be_itself_db & test_cannot_be_own_parent
Cycle indirect interdit	                                                        → test_cycle_detection_db & test_cycle_detection_indirect
Si recipe_type = VARIATION, parent_recipe obligatoire	                        → test_variation_requires_parent
Si parent_recipe est défini, recipe_type doit être VARIATION	                → test_parent_requires_variation_type
Une recette doit avoir au moins un ingrédient ou une sous-recette	            → test_recipe_requires_ingredient_or_subrecipe & test_recipe_without_ingredients_and_subrecipes_is_invalid
Une recette doit avoir au moins une étape	                                    → test_recipe_requires_step & test_recipe_without_steps_is_invalid
PATCH ne peut pas contenir des steps	                                        → test_patch_with_steps_is_rejected
PATCH ne modifie pas le contenu imbriqué (sub_recipe, steps)	                → test_patch_step_does_not_affect_recipe, test_patch_subrecipe_does_not_affect_parent, test_patch_description_does_not_remove_steps
Suppression impossible si recette utilisée comme sous-recette	                → test_delete_recipe_used_as_subrecipe
CRUD complet API et nested OK	                                                → test_create_nested_ingredient_api, test_delete_nested_step_api, etc.

Contraintes Métier :
1. Champs obligatoires
    ◦ recipe_name, chef_name, recipe_type toujours requis
    ◦ Si recipe_type == VARIATION, alors parent_recipe requis
2. Relations de contenu
    ◦ Minimum requis : un ingrédient ou sous-recette ET au moins une étape
    ◦ Les sous-recettes ne doivent pas former de cycle
3. Servings
    ◦ Champs servings_min et servings_max doivent être ≥ 1
    ◦ Si l’un est absent, l’autre est copié
    ◦ Peuvent être automatiquement remplis via Pan.units_in_mold * pan_quantity
4. Parent Recipe & context
    ◦ Le context_name est suggéré automatiquement si la recette est une variation
    ◦ Une recette ne peut pas être sa propre parent
    ◦ Les cycles indirects sont détectés et interdits
5. Traduction utilisateur
    ◦ Champs normalisés automatiquement (recipe_name, chef_name, etc.)
    ◦ Champs description, trick, source, context_name sont optionnels mais contrôlés si présents

Contraintes Techniques :
1. Types de Données
    ◦ servings_min & servings_max : PositiveIntegerField(null=True)
    ◦ recipe_type : CharField(choices=RECIPE_TYPE_CHOICES)
    ◦ parent_recipe : FK nullable vers Recipe (auto-référentielle)
2. Intégrité & Normalisation
    ◦ clean() centralise toutes les règles métier
    ◦ Unicité sur le couple (recipe_name, chef_name, context_name)
    ◦ Champs normalisés avec normalize_case()
3. Champs calculés ou dérivés
    ◦ Auto-remplissage contextuel de context_name et servings
4. Suppression protégée
    ◦ Impossible de supprimer une recette si elle est utilisée comme sous-recette (on_delete=PROTECT sur SubRecipe)



### Gestion des Endpoints Imbriqués pour les Sous-éléments de Recette
Modèles concernés : RecipeIngredient, SubRecipe, RecipeStep

Principe : 
- Ces modèles sont liés à Recipe via une ForeignKey. 
- Pour une meilleure cohérence et UX dans l’API, ces ressources sont gérées via des endpoints imbriqués :
    Ex. :
            POST /recipes/<recipe_id>/ingredients/
            POST /recipes/<recipe_id>/sub-recipes/
            POST /recipes/<recipe_id>/steps/

Objectif :
Permettre la création et mise à jour de RecipeStep, SubRecipe et RecipeIngredient dans un contexte imbriqué (/recipes/<id>/steps/) sans dépendre de signaux, 
tout en maintenant les contraintes métier (ex : ne pas supprimer le dernier step d'une recette).

Comportement des Serializers associés :
1. get_fields()
- Rend le champ recipe optionnel uniquement si la requête est faite via un endpoint imbriqué (ex : (/recipes/<id>/steps/)).
- Supprime complètement le champ recipe si le serializer est utilisé dans un contexte "nested" (par un autre serializer).
2. run_validation()
- Injecte automatiquement la recipe à partir des paramètres de l’URL (ex. recipe_pk) si elle n’est pas présente dans le payload.
  Cela permet d'utiliser des nested routes sans dupliquer la logique de relation.
3. extra_kwargs
- Définit recipe comme read_only pour éviter toute modification postérieure (sécurité métier).


### Description des paramètres d’entrée de /recipes/adapt/
Cette API permet d'adapter une recette existante à un nouveau contexte, selon deux logiques :

Cas 1 – Adaptation d’un moule vers un autre moule :
Requiert : recipe_id, source_pan_id, target_pan_id
L’adaptation est basée sur les volumes des deux moules

Cas 2 – Adaptation à un moule cible en connaissant les portions d’origine :
Requiert : recipe_id, initial_servings, target_pan_id
L’adaptation estime le volume d’origine à partir du nombre de portions (1 portion ≈ 150ml)

Priorité en cas de données mixtes :
Si à la fois source_pan_id et initial_servings sont fournis, l’API donne priorité à source_pan_id.
Cela garantit une adaptation plus précise basée sur les volumes réels des moules.
Le champ initial_servings est ignoré dans ce cas.

Exemple :
{
  "recipe_id": 42,
  "source_pan_id": 5,
  "initial_servings": 6,
  "target_pan_id": 8
}
Ici interprété comme une adaptation de pan → pan (Cas 1)


####### Mise à jour d'une recette (PATCH vs PUT)

### PATCH /recipes/<id>/

Pour modifier uniquement des champs simples (nom, chef, nombre de portions, etc.).

- Vous **ne pouvez pas** modifier les ingrédients, étapes ou sous-recettes via ce endpoint.
- Pour cela, utilisez les endpoints imbriqués ci-dessous.

---

### Endpoints imbriqués à utiliser :

#### Ingrédients
- `POST /recipes/<id>/ingredients/` → Ajouter un ingrédient
- `PATCH /recipes/<id>/ingredients/<id>/` → Modifier un ingrédient
- `DELETE /recipes/<id>/ingredients/<id>/` → Supprimer un ingrédient

#### Étapes
- `POST /recipes/<id>/steps/`
- `PATCH /recipes/<id>/steps/<id>/`
- `DELETE /recipes/<id>/steps/<id>/`

#### Sous-recettes
- `POST /recipes/<id>/sub-recipes/`
- `PATCH /recipes/<id>/sub-recipes/<id>/`
- `DELETE /recipes/<id>/sub-recipes/<id>/`

---

### PUT /recipes/<id>/

Utilisez ce endpoint uniquement si vous souhaitez **remplacer entièrement** tous les blocs :
- Ingrédients
- Étapes
- Sous-recettes

**Attention** : tout ce qui n’est pas envoyé sera supprimé.

---



####### Synthèse des Contraintes pour les Calculs d’Adaptation, d’Estimation et de Suggestion

# Contraintes Métier

        Fonction / Endpoint	                                Contraintes Métier	                                             Test Correspondant
/api/recipes-adapt/ (adaptation de recettes)	- Oblige la présence d’un recipe_id.                                    - test_recipe_adaptation_api_pan_to_pan
                                                - Vérifie les priorités des paramètres (source_pan_id prioritaire).     - test_recipe_adaptation_api_servings_to_volume
                                                - Les servings doivent être ≥ 1.                                        - test_recipe_adaptation_api_servings_to_servings
                                                - Les pans doivent être valides et exister si fournis.                  - test_recipe_adaptation_api_prioritizes_source_pan
                                                - Si la recette n’a pas de pan, alors servings_min et servings_max 
                                                doivent être définis pour calculer.	

/api/pans/estimate-volume/	                    - Si pan_id est fourni, les dimensions ne doivent pas être envoyées.    - test_pan_estimation_api
                                                - Si pan_id est absent, les dimensions doivent être complètes 
                                                selon le type de pan.
                                                - Les dimensions doivent être strictement positives.

/api/pan-suggesttion/	                        - Le nombre de servings cible est requis et ≥ 1.                        - test_suggest_pans_api
                                                - Retourne tous les pans compatibles 
                                                (où servings_min ≤ target ≤ servings_max).	

# Contraintes Techniques
Les endpoints d’estimation et de suggestion sont indépendants et séparés de l’endpoint d’adaptation (/recipes-adapt/).
Les calculs utilisent une convention métier :
➝ 1 portion = 150 ml par défaut (peut évoluer dans une version future).
Les suggestions de pans sont basées sur l’intervalle (servings_min, servings_max) enregistré dans le modèle Pan.

# Contraintes de Validation API
Validation stricte des combinaisons d’entrées :
Exemple : Il est interdit d’envoyer à la fois un pan_id et des dimensions dans /pans/estimate-volume/.
Dans /recipes-adapt/, si un source_pan_id est présent, la logique Serving → Serving est ignorée.




######## Gestion multi-utilisateurs, invités, et partage dans l’app

#Contexte & Objectifs
- Gérer une base partagée de recettes, ingrédients, moules, magasins : certains objets sont “de base” (accessibles à tous), 
d’autres sont “privés” ou publics à l’utilisateur.
- Supporter l’utilisation sans compte (mode invité) : un utilisateur non connecté doit pouvoir consulter, créer 
et organiser ses propres objets (ex : ses recettes, ses ingrédients, ses moules…) sans création de compte obligatoire.
- Préparer le passage futur à un mode full communautaire (auth, partage avancé).

# Règles d’usage :
user : utilisateur propriétaire, ou None pour invité ou “objet de base”
guest_id : UUID unique par invité/frontend, stocké côté client (cookie, localStorage, etc.), utilisé en header X-Guest-Id dans chaque requête
visibility : privé/public
is_default : objet de base, fourni par l’app, non modifiable/supprimable

# Permissions et visibilité des objets
Objet “de base” (is_default=True) : visible en lecture par tous, jamais modifiable/supprimable par un utilisateur (ni invité, ni user)
Objet public (visibility="public") : visible par tous, modifiable/supprimable uniquement par son propriétaire (user ou guest_id)
Objet privé (visibility="private") :
    - Si user connecté : visible uniquement par ce user
    - Si invité : visible uniquement par ce guest_id

# NB dev front : 
Pour garantir une expérience fluide sans compte, le front doit générer et conserver un guest_id (UUID) persistant côté client (cookie/localStorage)
et l’envoyer systématiquement en header X-Guest-Id sur les requêtes d’édition/lecture (GET, POST, PATCH, DELETE…).
(Si l’utilisateur s’inscrit, une logique pourra migrer ses objets “invités” vers son compte.)

# Filtrage (backend)
Chaque ViewSet utilise un mixin standardisé (exemple pour Recipe : GuestUserRecipeMixin) pour :
- Restreindre l’accès et l’édition selon les règles ci-dessus
- Attribuer le bon propriétaire (user ou guest_id) à la création
- Ne jamais permettre modification/suppression d’un objet “de base” (is_default=True)
- Supporter la recherche, le filtrage et l’ordering selon les besoins métier

### Synthèse des Contraintes pour l’Adaptation, la Visibilité, et la Gestion Multi-Utilisateurs

Gestion de la visibilité, du “soft-hide” et des droits d’édition/suppression

    Règle/Contrainte	                                     Explication	                                                  Test(s) associé(s)
Objet “de base” (is_default=True)	Visible en lecture seule pour tous (invités et users), jamais modifiable            
                                    ou supprimable (ni via API ni admin, hors superuser).	                            test_default_object_is_readonly
Objet privé (visibility="private")	Visible seulement par son propriétaire (user ou guest_id). Modification et          
                                    suppression autorisées uniquement pour le propriétaire.	                            test_visibility_private_logic
Objet public (visibility="public")	Visible par tous. Modification/suppression réservées au propriétaire.	            test_visibility_public_logic
Invités (“guest_id”)	            Un invité identifié par un guest_id unique peut créer, éditer et masquer ses        
                                    propres objets. Les objets publics ou “de base” restent visibles en lecture.	    test_adaptation_permissions_guest
Soft-hide (UserRecipeVisibility)	Les recettes de base ne sont jamais supprimées pour un user/guest : une 
                                    suppression entraîne la création d’une entrée UserRecipeVisibility avec 
                                    visible=False pour masquer la recette uniquement pour cet utilisateur/invité.	    test_soft_hide_base_recipe_for_user
Masquage logique (soft-hide)    	Un objet “de base” masqué reste accessible aux autres utilisateurs.	                test_soft_hide_base_recipe_for_user, test_soft_hide_for_guests
Adaptations (Fork/Adaptation)	    Un utilisateur peut adapter une recette “de base” (fork : création d’une 
                                    nouvelle recette liée par parent_recipe et recipe_type="VARIATION"), qui 
                                    devient son propre objet, privé ou public.	                                        test_filter_adaptations_by_parent, test_adaptation_permissions_guest

# Points d’attention techniques

- Mixin d’attribution : toute création d’objet attribue automatiquement l’auteur (user) ou le guest_id (pour les invités).
- Gestion du guest_id : le frontend doit générer un identifiant persistant pour chaque invité (UUID, stocké en localStorage/cookie) 
et l’envoyer en header X-Guest-Id à chaque requête.
- Soft-hide vs suppression : la suppression d’un objet “de base” par un user/guest ne supprime rien en base : elle ajoute une entrée 
de masquage dans UserRecipeVisibility (et exclut l’objet du queryset de l’utilisateur).
- Permissions customisées : les ViewSets utilisent une permission spécifique pour gérer ces logiques (CanSoftHideRecipeOrIsOwnerOrGuest).
- Cas d’adaptation : lors d’une adaptation (endpoint /adapt/), l’objet créé hérite toujours de is_default=False et visibility=private, 
sauf si l’utilisateur choisit explicitement le contraire et que c’est permis.
