"""
📌 Contexte du projet
Backend Django REST Framework (DRF) pour une application de pâtisserie.
L’objectif est de gérer les recettes, les ingrédients, leurs prix, les moules, 
et de calculer les coûts et quantités nécessaires en fonction des portions ou des moules utilisés.

✅ Fonctionnalités principales :
    - Gestion des ingrédients avec leurs catégories et labels.
    - Gestion des recettes, y compris les sous-recettes et les étapes (+ possibilité de dupliquer une recette ; + archivage ; + favoris ; + Adaptation intelligente ("fork")).
    - Recherche de recette par catégorie, par label, par prix, par ingrédient, par temps de préparation, etc.
    - Gestion des moules (pans) avec calcul automatique de volumes pour ajuster les quantités.
    - Calcul automatique des quantités en fonction des servings, du moule utilisé, d'une recette de référence, ou de quantités spécifiques d'un ou plusieurs ingrédient.
    - Calcul automatique du coût d’une recette en fonction du prix des ingrédients (option : en fonction de quel magasin peuvent provenir les ingrédients).
    - Possibilité d'application collaborative pour remplir la base de données (le prix des ingrédients de différentes marques et dans les différents magasins).
    - Gestion de compte utilisateur et compte premium.
    - Tests automatisés (modèles, validation, API CRUD et services) avec pytest.

📂 Architecture du projet
1. Applications Django
    - pastry_app/ (application principale) Contient toute la logique métier de l’application.
    - enchante/ (paramètres du projet) Contient la configuration globale du projet (settings.py, urls.py, wsgi.py).

2 Principaux fichiers Django
Fichier	Rôle
    models.py	    Définition des modèles : Ingredient, Recipe, Pan, Category, Label…
    serializers.py	Sérialisation des données pour Django REST Framework
    views.py	    Logique métier et endpoints API
    urls.py	        Routes de l'API
    admin.py	    Configuration de l’interface d’administration Django
    mixins.py	    Mixins de vues génériques réutilisables
    permissions.py	Classes de permissions personnalisées pour DRF
    constants.py	Variables constantes utilisées dans l’application
    utils.py	    Fonctions utilitaires et calculs d’adaptation
    tests/	        Dossier contenant tous les tests (modèle, validation, API/CRUD, services)
    static/	        Fichiers CSS & JS pour le mode admin
    settings.py	    Configuration principale de Django

📊 Modèles principaux
    1. Ingredient (Ingrédients) - Stocke les ingrédients et leurs catégories / labels associés.
        Nom unique (ingredient_name)
        Catégories (ManyToMany → Category)
        Labels (ManyToMany → Label)
        Références d’unité (ingredient_unit_references) → permet le calcul par poids unitaire
    2. Category (Catégories d’ingrédients et de recettes) - Classement des ingrédients et des recettes.
        category_name : Nom unique de la catégorie.
        category_type : recette, ingrédient ou both
        Relation ManyToMany avec Ingredient et Recipe (un ingrédient ou une recette peut avoir plusieurs catégories).
        Relation hiérarchique (parent_category)
    3. Label (Labels alimentaires et certifications) - Classement par label (ex: Bio, Vegan, AOC, etc.).
        label_name : Nom unique du label.
        Relation ManyToMany avec Ingredient et Recipe (un ingrédient ou une recette peut avoir plusieurs labels).
    4. Pan (Moules) - Gère les différents types de moules avec calcul de volume
        pan_name : Nom unique du moule
        pan_type : Type (round, square, custom)
        Dimensions + volume pré-calculé (volume_cm3_cache)
    5. Recipe (Recettes) - Stocke les informations principales d’une recette
        recipe_name : Nom unique de la recette
        ingredients : Relation avec Ingredient
        Chef (chef_name)
        Moule associé (pan)
        Portions (servings_min, servings_max)
        Poids total (total_recipe_quantity)
        Catégories / labels
        Gestion de la visibilité et propriété (user/guest_id)
        Relation vers recettes parentes (forks, variations)
    6. RecipeIngredient (Association recette - ingrédients) - Associe des ingrédients à une recette avec une quantité donnée.
        recipe : ForeignKey vers Recipe.
        ingredient : ForeignKey vers Ingredient.
        quantity : Quantité de l’ingrédient requise pour cette recette.
        unit : Unité de mesure utilisée (grammes, litres, etc.).
    7. RecipeStep (Étapes de la recette) - Stocke chaque étape de préparation d’une recette.
        recipe : ForeignKey vers Recipe.
        step_number : Numéro de l’étape (permet de garder l’ordre).
        description : Détail de l’étape de préparation.
    8. SubRecipe (Recette dans une autre recette) - Gère les recettes qui sont des sous-recettes d’une autre recette.
        main_recipe : ForeignKey vers la recette principale.
        sub_recipe : ForeignKey vers une autre Recipe (qui est une sous-recette).
        quantity : Quantité de la sous-recette utilisée dans la recette principale.
    9. IngredientPrice (Prix des ingrédients par magasin) - Stocke le prix des ingrédients selon le magasin.
        ingredient : ForeignKey vers Ingredient (chaque prix est lié à un ingrédient précis).
        store : Nom du magasin où le prix est applicable.
        price : Prix de l’ingrédient dans ce magasin.
    10. IngredientUnitReference
        Lien vers un Ingredient
        Nom d’unité standardisée (unit)
        Poids unitaire en grammes (unit_weight_g)

📐 Fonctionnalités avancées : Adaptation, Estimation et Suggestion
Le backend intègre une logique métier avancée autour de l’adaptation des recettes, la suggestion de moules et l’estimation des portions ou volumes.
Use cases supportés :

Adapter une recette vers un autre moule (Pan → Pan)
➝ Ajuste les quantités d’une recette en fonction d’un moule source et d’un moule cible.

Adapter une recette en fonction d’un nombre de portions vers un moule (Serving → Pan)
➝ L’utilisateur précise le nombre de portions souhaité et le moule cible.

Adapter une recette d’un nombre de portions vers un autre (Serving → Serving)
➝ Permet de recalculer les quantités sans dépendre d’un moule.

Adapter une recette en fonction d'une recette de référence 
➝ Permet d'adapter la recette en se basant sur une recette de référence vers le moule cible ou vers le nombre de portions souhaité.

Estimer combien de portions une recette donne dans un moule donné (Pan → Serving)
➝ Fournit l’intervalle de portions réalisables avec la recette dans un moule spécifique.

Estimer le nombre de portions réalisables avec un moule sans passer par une recette (Pan seul)
➝ Fournit le volume et un intervalle de portions pour un moule existant ou défini par ses dimensions.

Suggérer les moules adaptés pour un nombre de portions (Serving seul)
➝ L’utilisateur fournit le nombre de portions souhaitées et obtient une liste de moules compatibles.

Suggérer des recettes de référence pertinentes
➝ A partir d'une recette, est proposé à l'utilisateur une liste de recette de références 'similaires' avec la priorité suivante : 
    1. même sous-catégorie
    2. Même catégorie
    3. Autre recette compatible

Si plusieurs modes d’adaptation sont possibles dans une requête, le backend applique une priorité stricte :
Pan → Pan (prioritaire si source_pan et target_pan sont fournis)
Sinon Serving → Pan
Sinon Serving → Serving
Sinon Pan → Serving

🔧 Endpoints API associés :
/api/recipes-adapt/	         ➝ Endpoint central pour les cas 1 à 4
/api/pans/estimate-volume/   ➝ Estimation volume + portions à partir d’un moule (cas 5)
/api/pans/suggest/	         ➝ Suggestion de moules selon un nombre de portions (cas 6)


📌 Tests mis en place
Organisation des tests :

tests/
│── models/  → Tests des modèles (`test_category_model.py`, `test_ingredient_model.py`, etc.)
│── validation/  → Tests de validation métier (`test_category_validation.py`, `test_recipe_validation.py`, etc.)
│── crud/  → Tests CRUD via API (`test_category.py`, `test_ingredient.py`, etc.)
│── base_api_test.py  → Classe `BaseAPITest` pour factoriser les tests API
|── services/  → Tests des services d'adaptation, d'estimation et de suggestion de moules et servings et de recette de référence.


📐 Fonctionnalités avancées : Adaptation, Forks, Visibilité & Gestion utilisateurs/invités

L’application permet :

- L’adaptation intelligente (“fork”) : chaque utilisateur (ou invité) peut créer une adaptation personnalisée d’une recette existante 
(par exemple, ajuster pour un autre moule, modifier des ingrédients ou les quantités).
    - L’adaptation crée un nouvel objet Recipe lié à la recette mère (parent_recipe, recipe_type="VARIATION").
    - Les objets “adaptés” sont visibles, modifiables et supprimables uniquement par leur créateur (user ou guest_id).
    - Les recettes de base ou publiques restent inaltérées et non dupliquées.

- La gestion fluide des invités (“guest”) : un invité (utilisateur sans compte) possède un identifiant unique côté front (guest_id) 
pour retrouver ses objets (recettes, ingrédients, etc.).

- Le masquage logique (soft-hide) : suppression d’une recette de base = masquage uniquement pour le user/guest, sans suppression réelle en base. 
Les autres utilisateurs continuent à voir l’objet.

- Contrôle strict des droits : les permissions API empêchent toute modification/suppression d’un objet “de base” ou public par un non-propriétaire. 
Les objets privés restent visibles exclusivement pour leur créateur.

# Exemple d’usage côté front :

- Lorsqu’un invité ou utilisateur adapte (“fork”) une recette, il obtient sa propre version, indépendante, sans polluer la base commune.
- Un bouton “masquer cette recette de base” ne la supprime pas : elle est juste cachée à l’utilisateur concerné.
- Toute requête de modification/suppression sur un objet de base est refusée (statut 403).

Objectif :
Favoriser l’adaptabilité et la personnalisation, tout en évitant la duplication de données, en respectant les droits de chaque utilisateur 
et en gardant une UX cohérente même pour les invités.

"""